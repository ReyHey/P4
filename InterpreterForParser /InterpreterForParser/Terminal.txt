puvikaransanthirasegaram@h229 P4 % make
java -jar Dependencies/java-cup-11b.jar -expect 1 -parser Parser -interface Parser.cup
Warning : *** Shift/Reduce conflict found in state #122
  between value ::= IDENTIFIER func_call (*) 
  and     stmt ::= IDENTIFIER func_call (*) NEWLINE 
  under symbol NEWLINE
  Resolved in favor of shifting.

------- CUP v0.11b 20160615 (GIT 4ac7450) Parser Generation Summary -------
  0 errors and 1 warning
  59 terminals, 57 non-terminals, and 124 productions declared, 
  producing 233 unique parse states.
  0 terminals declared but not used.
  0 non-terminals declared but not used.
  0 productions never reduced.
  1 conflict detected (1 expected).
  Code written to "Parser.java", and "sym.java".
---------------------------------------------------- (CUP v0.11b 20160615 (GIT 4ac7450))
javac -cp .:Dependencies/java-cup-11b.jar Simpleton.java sym.java Lexer.java Parser.java
Note: Simpleton.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
java -cp .:Dependencies/java-cup-11b.jar Simpleton
Parsing input.txt
# Initializing parser
Token Read: #51 = FUNCTION
Shift #51
Token Read: #52 = VOID
Shift #52
Token Read: #10 = IDENTIFIER
Reduce prod #70 =  return_type ::= VOID 
Shift #10
Token Read: #24 = LPAREN
Shift #24
Token Read: #25 = RPAREN
Reduce prod #72 =  formal_parameter_list ::= 
Shift #25
Token Read: #26 = LCURLY
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #24 = LPAREN
Shift #24
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #47 = COMMA
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #122 =  actual_parameter ::= expression 
Shift #47
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #25 = RPAREN
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #122 =  actual_parameter ::= expression 
Reduce prod #121 =  multiple_actual_parameters ::= 
Reduce prod #120 =  multiple_actual_parameters ::= COMMA actual_parameter multiple_actual_parameters 
Reduce prod #118 =  actual_parameter_list ::= actual_parameter multiple_actual_parameters 
Shift #25
Token Read: #49 = NEWLINE
Reduce prod #116 =  func_call ::= LPAREN actual_parameter_list RPAREN 
Reduce prod #35 =  value ::= IDENTIFIER func_call 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #49 =  initialization ::= EQ expression 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #10 = IDENTIFIER
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #10
Token Read: #24 = LPAREN
Shift #24
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #48 = DOT
Shift #48
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #24 = LPAREN
Shift #24
Token Read: #25 = RPAREN
Reduce prod #119 =  actual_parameter_list ::= 
Shift #25
Token Read: #16 = PLUS
Reduce prod #117 =  func_call ::= DOT IDENTIFIER LPAREN actual_parameter_list RPAREN 
Reduce prod #35 =  value ::= IDENTIFIER func_call 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #16
Token Read: #9 = STRINGLIT
Shift #9
Token Read: #25 = RPAREN
Reduce prod #38 =  constant ::= STRINGLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #20 =  arithmetic_expression ::= arithmetic_expression PLUS term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #122 =  actual_parameter ::= expression 
Reduce prod #121 =  multiple_actual_parameters ::= 
Reduce prod #118 =  actual_parameter_list ::= actual_parameter multiple_actual_parameters 
Shift #25
Token Read: #49 = NEWLINE
Reduce prod #116 =  func_call ::= LPAREN actual_parameter_list RPAREN 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #90 =  stmt ::= IDENTIFIER func_call NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #27
Token Read: #49 = NEWLINE
Reduce prod #108 =  block ::= LCURLY NEWLINE stmt_list RCURLY 
function_decl
Reduce prod #68 =  function_decl ::= FUNCTION return_type IDENTIFIER LPAREN formal_parameter_list RPAREN block 
Reduce prod #5 =  declaration ::= function_decl 
Shift #49
Token Read: #51 = FUNCTION
Shift #51
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Reduce prod #69 =  return_type ::= type 
Shift #10
Token Read: #24 = LPAREN
Shift #24
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #47 = COMMA
Reduce prod #75 =  formal_parameter ::= type IDENTIFIER 
Shift #47
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #25 = RPAREN
Reduce prod #75 =  formal_parameter ::= type IDENTIFIER 
Reduce prod #74 =  multiple_formal_parameters ::= 
Reduce prod #73 =  multiple_formal_parameters ::= COMMA formal_parameter multiple_formal_parameters 
Reduce prod #71 =  formal_parameter_list ::= formal_parameter multiple_formal_parameters 
Shift #25
Token Read: #26 = LCURLY
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #51 =  initialization ::= 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #53 = NUMBER
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #51 =  initialization ::= 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #53 = NUMBER
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #51 =  initialization ::= 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #42 = IF
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #42
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #12 = EQEQ
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #12
Token Read: #7 = NUMBERLIT
Reduce prod #40 =  eval_symbol ::= EQEQ 
Shift #7
Token Read: #34 = OR
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Shift #34
Token Read: #10 = IDENTIFIER
Reduce prod #47 =  logical_symbol ::= OR 
Shift #10
Token Read: #12 = EQEQ
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #12
Token Read: #7 = NUMBERLIT
Reduce prod #40 =  eval_symbol ::= EQEQ 
Shift #7
Token Read: #26 = LCURLY
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #14 =  expression ::= expression logical_symbol deep 
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #49 = NEWLINE
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #49 =  initialization ::= EQ expression 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #5 = RETURN
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #5
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #49 = NEWLINE
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #96 =  return_stmt ::= RETURN expression 
Reduce prod #92 =  jump_stmt ::= return_stmt 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #88 =  stmt ::= jump_stmt NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #27
Token Read: #49 = NEWLINE
Shift #49
Token Read: #42 = IF
Reduce prod #104 =  if_stmt ::= IF expression LCURLY NEWLINE stmt_list RCURLY NEWLINE 
Reduce prod #78 =  stmt ::= if_stmt 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #42
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #14 = LEQ
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #14
Token Read: #10 = IDENTIFIER
Reduce prod #42 =  eval_symbol ::= LEQ 
Shift #10
Token Read: #26 = LCURLY
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #109 =  assign_stmt ::= IDENTIFIER EQ expression 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #83 =  stmt ::= assign_stmt NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #27
Token Read: #49 = NEWLINE
Shift #49
Token Read: #43 = ELSE
Reduce prod #104 =  if_stmt ::= IF expression LCURLY NEWLINE stmt_list RCURLY NEWLINE 
Shift #43
Token Read: #26 = LCURLY
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #109 =  assign_stmt ::= IDENTIFIER EQ expression 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #83 =  stmt ::= assign_stmt NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #27
Token Read: #49 = NEWLINE
Reduce prod #108 =  block ::= LCURLY NEWLINE stmt_list RCURLY 
Shift #49
Token Read: #10 = IDENTIFIER
Reduce prod #105 =  if_else_stmt ::= if_stmt ELSE block NEWLINE 
Reduce prod #79 =  stmt ::= if_else_stmt 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #109 =  assign_stmt ::= IDENTIFIER EQ expression 
Shift #49
Token Read: #37 = WHILE
Reduce prod #83 =  stmt ::= assign_stmt NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #37
Token Read: #24 = LPAREN
Shift #24
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #33 = MOD
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Shift #33
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #13 = NOTEQ
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #25 =  term ::= term MOD factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #13
Token Read: #7 = NUMBERLIT
Reduce prod #41 =  eval_symbol ::= NOTEQ 
Shift #7
Token Read: #34 = OR
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Shift #34
Token Read: #10 = IDENTIFIER
Reduce prod #47 =  logical_symbol ::= OR 
Shift #10
Token Read: #33 = MOD
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Shift #33
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #13 = NOTEQ
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #25 =  term ::= term MOD factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #13
Token Read: #7 = NUMBERLIT
Reduce prod #41 =  eval_symbol ::= NOTEQ 
Shift #7
Token Read: #25 = RPAREN
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #14 =  expression ::= expression logical_symbol deep 
Shift #25
Token Read: #35 = AND
Reduce prod #31 =  value ::= LPAREN expression RPAREN 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Shift #35
Token Read: #10 = IDENTIFIER
Reduce prod #46 =  logical_symbol ::= AND 
Shift #10
Token Read: #30 = RANGLE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #30
Token Read: #7 = NUMBERLIT
Reduce prod #45 =  eval_symbol ::= RANGLE 
Shift #7
Token Read: #26 = LCURLY
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #14 =  expression ::= expression logical_symbol deep 
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #17 = MINUS
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #17
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #49 = NEWLINE
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #21 =  arithmetic_expression ::= arithmetic_expression MINUS term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #109 =  assign_stmt ::= IDENTIFIER EQ expression 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #83 =  stmt ::= assign_stmt NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #27
Token Read: #49 = NEWLINE
Reduce prod #108 =  block ::= LCURLY NEWLINE stmt_list RCURLY 
Reduce prod #106 =  while_stmt ::= WHILE expression block 
Shift #49
Token Read: #10 = IDENTIFIER
Reduce prod #81 =  stmt ::= while_stmt NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #109 =  assign_stmt ::= IDENTIFIER EQ expression 
Shift #49
Token Read: #38 = FOREACH
Reduce prod #83 =  stmt ::= assign_stmt NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #38
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #6 = IN
Shift #6
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #26 = LCURLY
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #49 = NEWLINE
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #49 =  initialization ::= EQ expression 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #54 = STRING
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #54
Token Read: #10 = IDENTIFIER
Reduce prod #10 =  primitiv_type ::= STRING 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #9 = STRINGLIT
Shift #9
Token Read: #49 = NEWLINE
Reduce prod #38 =  constant ::= STRINGLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #49 =  initialization ::= EQ expression 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #27
Token Read: #49 = NEWLINE
Reduce prod #108 =  block ::= LCURLY NEWLINE stmt_list RCURLY 
Reduce prod #107 =  foreach_stmt ::= FOREACH type IDENTIFIER IN IDENTIFIER block 
Shift #49
Token Read: #39 = SWITCH
Reduce prod #82 =  stmt ::= foreach_stmt NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #39
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #26 = LCURLY
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #98 =  optional_newline ::= 
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #40 = CASE
Reduce prod #97 =  optional_newline ::= NEWLINE 
Shift #40
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #46 = COLON
Reduce prod #37 =  constant ::= NUMBERLIT 
Shift #46
Token Read: #40 = CASE
Reduce prod #98 =  optional_newline ::= 
Reduce prod #103 =  case_stmt ::= CASE constant COLON optional_newline 
Reduce prod #101 =  case_stmts ::= case_stmt 
Shift #40
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #46 = COLON
Reduce prod #37 =  constant ::= NUMBERLIT 
Shift #46
Token Read: #49 = NEWLINE
Shift #49
Token Read: #53 = NUMBER
Reduce prod #97 =  optional_newline ::= NEWLINE 
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #7 = NUMBERLIT
Shift #7
Exception in thread "main" java.lang.Error: Error: could not match input
	at Lexer.zzScanError(Lexer.java:945)
	at Lexer.next_token(Lexer.java:1413)
	at java_cup.runtime.lr_parser.scan(lr_parser.java:366)
	at java_cup.runtime.lr_parser.debug_parse(lr_parser.java:885)
	at Simpleton.main(Simpleton.java:9)
make: *** [Simpleton] Error 1
puvikaransanthirasegaram@h229 P4 % 
