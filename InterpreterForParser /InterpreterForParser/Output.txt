# Initializing parser
Token Read: #51 = FUNCTION
Shift #51
Token Read: #52 = VOID
Shift #52
Token Read: #10 = IDENTIFIER
Reduce prod #70 =  return_type ::= VOID 
Shift #10
Token Read: #24 = LPAREN
Shift #24
Token Read: #25 = RPAREN
Reduce prod #72 =  formal_parameter_list ::= 
Shift #25
Token Read: #26 = LCURLY
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #24 = LPAREN
Shift #24
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #47 = COMMA
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #123 =  actual_parameter ::= expression 
Shift #47
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #25 = RPAREN
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #123 =  actual_parameter ::= expression 
Reduce prod #122 =  multiple_actual_parameters ::= 
Reduce prod #121 =  multiple_actual_parameters ::= COMMA actual_parameter multiple_actual_parameters 
Reduce prod #119 =  actual_parameter_list ::= actual_parameter multiple_actual_parameters 
Shift #25
Token Read: #49 = NEWLINE
Reduce prod #117 =  func_call ::= LPAREN actual_parameter_list RPAREN 
Reduce prod #35 =  value ::= IDENTIFIER func_call 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #49 =  initialization ::= EQ expression 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #10 = IDENTIFIER
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #10
Token Read: #24 = LPAREN
Shift #24
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #48 = DOT
Shift #48
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #24 = LPAREN
Shift #24
Token Read: #25 = RPAREN
Reduce prod #120 =  actual_parameter_list ::= 
Shift #25
Token Read: #16 = PLUS
Reduce prod #118 =  func_call ::= DOT IDENTIFIER LPAREN actual_parameter_list RPAREN 
Reduce prod #35 =  value ::= IDENTIFIER func_call 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #16
Token Read: #9 = STRINGLIT
Shift #9
Token Read: #25 = RPAREN
Reduce prod #38 =  constant ::= STRINGLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #20 =  arithmetic_expression ::= arithmetic_expression PLUS term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #123 =  actual_parameter ::= expression 
Reduce prod #122 =  multiple_actual_parameters ::= 
Reduce prod #119 =  actual_parameter_list ::= actual_parameter multiple_actual_parameters 
Shift #25
Token Read: #49 = NEWLINE
Reduce prod #117 =  func_call ::= LPAREN actual_parameter_list RPAREN 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #90 =  stmt ::= IDENTIFIER func_call NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #27
Token Read: #49 = NEWLINE
Reduce prod #109 =  block ::= LCURLY NEWLINE stmt_list RCURLY 
function_decl
Reduce prod #68 =  function_decl ::= FUNCTION return_type IDENTIFIER LPAREN formal_parameter_list RPAREN block 
Reduce prod #5 =  declaration ::= function_decl 
Shift #49
Token Read: #51 = FUNCTION
Shift #51
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Reduce prod #69 =  return_type ::= type 
Shift #10
Token Read: #24 = LPAREN
Shift #24
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #47 = COMMA
Reduce prod #75 =  formal_parameter ::= type IDENTIFIER 
Shift #47
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #25 = RPAREN
Reduce prod #75 =  formal_parameter ::= type IDENTIFIER 
Reduce prod #74 =  multiple_formal_parameters ::= 
Reduce prod #73 =  multiple_formal_parameters ::= COMMA formal_parameter multiple_formal_parameters 
Reduce prod #71 =  formal_parameter_list ::= formal_parameter multiple_formal_parameters 
Shift #25
Token Read: #26 = LCURLY
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #51 =  initialization ::= 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #53 = NUMBER
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #51 =  initialization ::= 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #53 = NUMBER
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #51 =  initialization ::= 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #42 = IF
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #42
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #12 = EQEQ
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #12
Token Read: #7 = NUMBERLIT
Reduce prod #40 =  eval_symbol ::= EQEQ 
Shift #7
Token Read: #34 = OR
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Shift #34
Token Read: #10 = IDENTIFIER
Reduce prod #47 =  logical_symbol ::= OR 
Shift #10
Token Read: #12 = EQEQ
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #12
Token Read: #7 = NUMBERLIT
Reduce prod #40 =  eval_symbol ::= EQEQ 
Shift #7
Token Read: #26 = LCURLY
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #14 =  expression ::= expression logical_symbol deep 
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #49 = NEWLINE
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #49 =  initialization ::= EQ expression 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #5 = RETURN
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #5
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #49 = NEWLINE
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #96 =  return_stmt ::= RETURN expression 
Reduce prod #92 =  jump_stmt ::= return_stmt 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #88 =  stmt ::= jump_stmt NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #27
Token Read: #49 = NEWLINE
Shift #49
Token Read: #42 = IF
Reduce prod #105 =  if_stmt ::= IF expression LCURLY NEWLINE stmt_list RCURLY NEWLINE 
Reduce prod #78 =  stmt ::= if_stmt 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #42
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #14 = LEQ
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #14
Token Read: #10 = IDENTIFIER
Reduce prod #42 =  eval_symbol ::= LEQ 
Shift #10
Token Read: #26 = LCURLY
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #110 =  assign_stmt ::= IDENTIFIER EQ expression 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #83 =  stmt ::= assign_stmt NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #27
Token Read: #49 = NEWLINE
Shift #49
Token Read: #43 = ELSE
Reduce prod #105 =  if_stmt ::= IF expression LCURLY NEWLINE stmt_list RCURLY NEWLINE 
Shift #43
Token Read: #26 = LCURLY
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #110 =  assign_stmt ::= IDENTIFIER EQ expression 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #83 =  stmt ::= assign_stmt NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #27
Token Read: #49 = NEWLINE
Reduce prod #109 =  block ::= LCURLY NEWLINE stmt_list RCURLY 
Shift #49
Token Read: #10 = IDENTIFIER
Reduce prod #106 =  if_else_stmt ::= if_stmt ELSE block NEWLINE 
Reduce prod #79 =  stmt ::= if_else_stmt 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #110 =  assign_stmt ::= IDENTIFIER EQ expression 
Shift #49
Token Read: #37 = WHILE
Reduce prod #83 =  stmt ::= assign_stmt NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #37
Token Read: #24 = LPAREN
Shift #24
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #33 = MOD
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Shift #33
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #13 = NOTEQ
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #25 =  term ::= term MOD factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #13
Token Read: #7 = NUMBERLIT
Reduce prod #41 =  eval_symbol ::= NOTEQ 
Shift #7
Token Read: #34 = OR
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Shift #34
Token Read: #10 = IDENTIFIER
Reduce prod #47 =  logical_symbol ::= OR 
Shift #10
Token Read: #33 = MOD
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Shift #33
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #13 = NOTEQ
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #25 =  term ::= term MOD factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #13
Token Read: #7 = NUMBERLIT
Reduce prod #41 =  eval_symbol ::= NOTEQ 
Shift #7
Token Read: #25 = RPAREN
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #14 =  expression ::= expression logical_symbol deep 
Shift #25
Token Read: #35 = AND
Reduce prod #31 =  value ::= LPAREN expression RPAREN 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Shift #35
Token Read: #10 = IDENTIFIER
Reduce prod #46 =  logical_symbol ::= AND 
Shift #10
Token Read: #30 = RANGLE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #30
Token Read: #7 = NUMBERLIT
Reduce prod #45 =  eval_symbol ::= RANGLE 
Shift #7
Token Read: #26 = LCURLY
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #18 =  deeper ::= arithmetic_expression eval_symbol arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #14 =  expression ::= expression logical_symbol deep 
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #17 = MINUS
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #17
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #49 = NEWLINE
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #21 =  arithmetic_expression ::= arithmetic_expression MINUS term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #110 =  assign_stmt ::= IDENTIFIER EQ expression 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #83 =  stmt ::= assign_stmt NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #27
Token Read: #49 = NEWLINE
Reduce prod #109 =  block ::= LCURLY NEWLINE stmt_list RCURLY 
Reduce prod #107 =  while_stmt ::= WHILE expression block 
Shift #49
Token Read: #10 = IDENTIFIER
Reduce prod #81 =  stmt ::= while_stmt NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #110 =  assign_stmt ::= IDENTIFIER EQ expression 
Shift #49
Token Read: #38 = FOREACH
Reduce prod #83 =  stmt ::= assign_stmt NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #38
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #6 = IN
Shift #6
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #26 = LCURLY
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #53 = NUMBER
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #49 = NEWLINE
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #49 =  initialization ::= EQ expression 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #54 = STRING
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #54
Token Read: #10 = IDENTIFIER
Reduce prod #10 =  primitiv_type ::= STRING 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #9 = STRINGLIT
Shift #9
Token Read: #49 = NEWLINE
Reduce prod #38 =  constant ::= STRINGLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #49 =  initialization ::= EQ expression 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #27 = RCURLY
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #27
Token Read: #49 = NEWLINE
Reduce prod #109 =  block ::= LCURLY NEWLINE stmt_list RCURLY 
Reduce prod #108 =  foreach_stmt ::= FOREACH type IDENTIFIER IN IDENTIFIER block 
Shift #49
Token Read: #39 = SWITCH
Reduce prod #82 =  stmt ::= foreach_stmt NEWLINE 
Reduce prod #76 =  stmt_list ::= stmt_list stmt 
Shift #39
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #26 = LCURLY
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #98 =  optional_newline ::= 
Shift #26
Token Read: #49 = NEWLINE
Shift #49
Token Read: #40 = CASE
Reduce prod #97 =  optional_newline ::= NEWLINE 
Shift #40
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #46 = COLON
Reduce prod #37 =  constant ::= NUMBERLIT 
Shift #46
Token Read: #40 = CASE
Reduce prod #98 =  optional_newline ::= 
Reduce prod #104 =  case_content ::= 
Reduce prod #102 =  case_stmt ::= CASE constant COLON optional_newline case_content 
Reduce prod #101 =  case_stmts ::= case_stmt 
Shift #40
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #46 = COLON
Reduce prod #37 =  constant ::= NUMBERLIT 
Shift #46
Token Read: #49 = NEWLINE
Shift #49
Token Read: #53 = NUMBER
Reduce prod #97 =  optional_newline ::= NEWLINE 
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #49 = NEWLINE
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #49 =  initialization ::= EQ expression 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #53 = NUMBER
Reduce prod #85 =  stmt ::= variable_decl NEWLINE 
Reduce prod #77 =  stmt_list ::= stmt 
Shift #53
Token Read: #10 = IDENTIFIER
Reduce prod #9 =  primitiv_type ::= NUMBER 
Reduce prod #12 =  type ::= primitiv_type 
Shift #10
Token Read: #11 = EQ
Shift #11
Token Read: #7 = NUMBERLIT
Shift #7
Token Read: #16 = PLUS
Reduce prod #37 =  constant ::= NUMBERLIT 
Reduce prod #33 =  value ::= constant 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #22 =  arithmetic_expression ::= term 
Shift #16
Token Read: #10 = IDENTIFIER
Shift #10
Token Read: #49 = NEWLINE
Reduce prod #34 =  value ::= IDENTIFIER 
Reduce prod #30 =  base ::= value 
Reduce prod #28 =  factor ::= base 
Reduce prod #26 =  term ::= factor 
Reduce prod #20 =  arithmetic_expression ::= arithmetic_expression PLUS term 
Reduce prod #19 =  deeper ::= arithmetic_expression 
Reduce prod #17 =  deep ::= deeper 
Reduce prod #15 =  expression ::= deep 
Reduce prod #49 =  initialization ::= EQ expression 
Reduce prod #48 =  variable_decl ::= type IDENTIFIER initialization 
Shift #49
Token Read: #40 = CASE
Syntax error at character 38 of input
instead expected token classes are [CONTINUE, RETURN, NUMBERLIT, BOOLEANLIT, STRINGLIT, IDENTIFIER, LPAREN, NOT, WHILE, FOREACH, SWITCH, IF, UMINUS, RANDOM, NEWLINE, CONSTANT, NUMBER, STRING, BOOLEAN, LIST]
# Attempting error recovery
# Finding recovery state on stack
# Pop stack by one, state was # 141
# Pop stack by one, state was # 68
# Pop stack by one, state was # 167
# Pop stack by one, state was # 165
# Pop stack by one, state was # 164
# Pop stack by one, state was # 163
# Pop stack by one, state was # 155
# Pop stack by one, state was # 156
# Pop stack by one, state was # 153
# Pop stack by one, state was # 152
# Pop stack by one, state was # 150
# Pop stack by one, state was # 149
# Pop stack by one, state was # 63
# Pop stack by one, state was # 61
# Pop stack by one, state was # 33
# Pop stack by one, state was # 31
# Pop stack by one, state was # 30
# Pop stack by one, state was # 22
# Pop stack by one, state was # 21
# Pop stack by one, state was # 20
# Pop stack by one, state was # 17
# Pop stack by one, state was # 10
# Pop stack by one, state was # 216
# Pop stack by one, state was # 4
# Pop stack by one, state was # 0
# No recovery state found on stack
# Error recovery fails
